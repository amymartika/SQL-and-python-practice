-- Challenge: "Contest Leaderboard"
-- The total score of a hacker is the sum of their maximum scores for all of 
-- the challenges. Write a query to print the hacker_id, name, and total score 
-- of the hackers ordered by the descending score. If more than one hacker achieved 
-- the same total socre, then sort the result by ascending hacker_id. Exclude 
-- all hackers with a total score of 0 from your result.

select 
    hackers.hacker_id,
    hackers.name,
    sum(best_submissions.score)
from 
    (select 
        hacker_id, 
        challenge_id,
        max(score) as score
     from submissions
     group by hacker_id, challenge_id) as best_submissions
join hackers
on best_submissions.hacker_id = hackers.hacker_id
group by hackers.hacker_id, hackers.name
having sum(best_submissions.score) > 0
order by sum(best_submissions.score) desc, hackers.hacker_id;

-- Challenge: "The PADS"
-- Generate the following two result sets: 
-- 1. Query an alphabetically ordered list of all names in OCCUPATIONS immediately
-- followed by the first letter of each profession as a parenthetical. For example:
-- AnActorName(A), ADoctorName (D), AProfessorName(P), and ASingerName(S). 
-- 2. Query the number of occurrences of each occupation in OCCUPATIONS. Sort 
-- the occurrences in ascending order, and output them in the following format: 
-- "There are a total of [occupation_count] [occupation]s.", where occupation_count
-- is the number of occurrences in an occpuation in OCCUPATIONS and occupation is the
-- lowercase occupation name. If more than one occupation has the same 
-- occupation_count, they should be ordered alphabetically. 
-- Note: There will be at least two entries in the table for each type of occupation. 

-- Query 1
select 
    concat(o.name, '(', left(o.occupation, 1), ')') as name_occupation
from occupations as o
order by o.name;

-- Query 2
select 
    concat('There are a total of ', count.occupation_count, ' ', lower(count.occupation), 's.') as totals from (
select
    occupation,
    count(occupation) over (partition by occupation) as occupation_count
from occupations) as count
group by count.occupation
order by count.occupation_count asc, count.occupation;

-- Challenge: "SQL Project Planning"
-- Write a query to output the start and end dates of projects listed by the 
-- number of days it took to complete the project in ascending order. If there is
-- more than on eproject that have the same number of completion days, then order
-- by the start date of the project. 

-- In progress query: 

with project_duration as (
select
    task_id, 
    start_date, 
    end_date, 
    datediff(end_date, start_date) as duration
from projects), 

days_between as (
select
    task_id,
    datediff(start_date, lag(end_date, 1) over (
        partition by task_id
        order by start_date)) as days
from projects
)

select 
    p.start_date, 
    p.end_date
from project_duration as p
join days_between as d
on p.task_id = d.task_id
where d.days > 1
order by p.duration asc, p.start_date;
